/* tslint:disable */
/* eslint-disable */
/**
 * Server API Retro
 * This is the Retro\'s front/back API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const BrandEnum = {
    Adidas: 'ADIDAS',
    Nike: 'NIKE',
    DrMartens: 'DR_MARTENS',
    MureGrand: 'MURE_GRAND',
    Weekday: 'WEEKDAY',
    Cos: 'COS',
    VonDutch: 'VON_DUTCH',
    Levis: 'LEVIS'
} as const;

export type BrandEnum = typeof BrandEnum[keyof typeof BrandEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const CategoryEnum = {
    Dresses: 'DRESSES',
    JumpersSweaters: 'JUMPERS_SWEATERS',
    TopsTshirts: 'TOPS_TSHIRTS',
    Trousers: 'TROUSERS',
    Leggings: 'LEGGINGS',
    Jumpsuits: 'JUMPSUITS',
    Nightwear: 'NIGHTWEAR',
    Lingerie: 'LINGERIE',
    Activewear: 'ACTIVEWEAR',
    Outwear: 'OUTWEAR',
    SuitsBlazers: 'SUITS_BLAZERS',
    Skirts: 'SKIRTS',
    Jeans: 'JEANS',
    Shorts: 'SHORTS',
    Swimwear: 'SWIMWEAR',
    Maternity: 'MATERNITY',
    Costumes: 'COSTUMES'
} as const;

export type CategoryEnum = typeof CategoryEnum[keyof typeof CategoryEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ColorEnum = {
    Black: 'BLACK',
    White: 'WHITE',
    Blue: 'BLUE',
    Grey: 'GREY',
    Beige: 'BEIGE',
    Multi: 'MULTI',
    Navy: 'NAVY',
    Brown: 'BROWN',
    Cream: 'CREAM',
    LightBlue: 'LIGHT_BLUE',
    Red: 'RED',
    Rose: 'ROSE',
    Green: 'GREEN',
    Pink: 'PINK',
    Khaki: 'KHAKI',
    Burgundy: 'BURGUNDY',
    DarkGreen: 'DARK_GREEN',
    Purple: 'PURPLE',
    Orange: 'ORANGE',
    Turquoise: 'TURQUOISE',
    Yellow: 'YELLOW',
    Lilac: 'LILAC',
    Coral: 'CORAL',
    Mustard: 'MUSTARD',
    Mint: 'MINT',
    Gold: 'GOLD',
    Silver: 'SILVER',
    Apricot: 'APRICOT'
} as const;

export type ColorEnum = typeof ColorEnum[keyof typeof ColorEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ConditionEnum = {
    NewWithTags: 'NEW_WITH_TAGS',
    NewWithoutTags: 'NEW_WITHOUT_TAGS',
    VeryGood: 'VERY_GOOD',
    Good: 'GOOD',
    Satisfactory: 'SATISFACTORY'
} as const;

export type ConditionEnum = typeof ConditionEnum[keyof typeof ConditionEnum];


/**
 * 
 * @export
 * @interface ItemDTO
 */
export interface ItemDTO {
    /**
     * Item\'s id
     * @type {string}
     * @memberof ItemDTO
     */
    'id'?: string;
    /**
     * Item\'s name
     * @type {string}
     * @memberof ItemDTO
     */
    'name'?: string;
    /**
     * Item\'s description
     * @type {string}
     * @memberof ItemDTO
     */
    'description'?: string;
    /**
     * Item\'s seller
     * @type {string}
     * @memberof ItemDTO
     */
    'sellerUsername'?: string;
    /**
     * Item\'s price
     * @type {number}
     * @memberof ItemDTO
     */
    'price'?: number;
    /**
     * Item\'s availability (sold or not)
     * @type {boolean}
     * @memberof ItemDTO
     */
    'available'?: boolean;
    /**
     * Item sold for women or not
     * @type {boolean}
     * @memberof ItemDTO
     */
    'women'?: boolean;
    /**
     * Item sold for men or not
     * @type {boolean}
     * @memberof ItemDTO
     */
    'men'?: boolean;
    /**
     * 
     * @type {BrandEnum}
     * @memberof ItemDTO
     */
    'brand'?: BrandEnum;
    /**
     * 
     * @type {CategoryEnum}
     * @memberof ItemDTO
     */
    'category'?: CategoryEnum;
    /**
     * 
     * @type {Array<ColorEnum>}
     * @memberof ItemDTO
     */
    'colors'?: Array<ColorEnum>;
    /**
     * 
     * @type {ConditionEnum}
     * @memberof ItemDTO
     */
    'condition'?: ConditionEnum;
    /**
     * 
     * @type {SizeEnum}
     * @memberof ItemDTO
     */
    'size'?: SizeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemDTO
     */
    'imagePaths'?: Array<string>;
}


/**
 * 
 * @export
 * @interface PasswordChangeRequest
 */
export interface PasswordChangeRequest {
    /**
     * User\'s old password
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'oldPassword': string;
    /**
     * User\'s new password
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SizeEnum = {
    Xxxs: 'XXXS',
    Xxs: 'XXS',
    Xs: 'XS',
    S: 'S',
    M: 'M',
    L: 'L',
    Xl: 'XL',
    Xxl: 'XXL',
    Xxxl: 'XXXL'
} as const;

export type SizeEnum = typeof SizeEnum[keyof typeof SizeEnum];


/**
 * 
 * @export
 * @interface UserCredentialsDTO
 */
export interface UserCredentialsDTO {
    /**
     * User\'s name
     * @type {string}
     * @memberof UserCredentialsDTO
     */
    'username': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof UserCredentialsDTO
     */
    'password': string;
    /**
     * User\'s email
     * @type {string}
     * @memberof UserCredentialsDTO
     */
    'email': string;
    /**
     * User\'s phone number
     * @type {string}
     * @memberof UserCredentialsDTO
     */
    'phoneNumber': string;
    /**
     * User\'s address
     * @type {string}
     * @memberof UserCredentialsDTO
     */
    'address': string;
    /**
     * User\'s profile picture path
     * @type {string}
     * @memberof UserCredentialsDTO
     */
    'profilePicturePath'?: string;
    /**
     * User\'s description
     * @type {string}
     * @memberof UserCredentialsDTO
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UserLogInDTO
 */
export interface UserLogInDTO {
    /**
     * User\'s name
     * @type {string}
     * @memberof UserLogInDTO
     */
    'username': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof UserLogInDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserPublicDTO
 */
export interface UserPublicDTO {
    /**
     * User\'s name
     * @type {string}
     * @memberof UserPublicDTO
     */
    'username': string;
    /**
     * User\'s profile picture path
     * @type {string}
     * @memberof UserPublicDTO
     */
    'profilePicturePath'?: string;
    /**
     * User\'s description
     * @type {string}
     * @memberof UserPublicDTO
     */
    'description'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes one specific item with its id
         * @param {string} id Item\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDeleteItemIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemDeleteItemIdDelete', 'id', id)
            const localVarPath = `/item/deleteItem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves one specific item with its id
         * @param {string} id Item\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemGetIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemGetIdGet', 'id', id)
            const localVarPath = `/item/get/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all items for sale on Retro
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemsForSaleGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/itemsForSale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all items on Retro
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new item for sale
         * @param {ItemDTO} itemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemNewItemPost: async (itemDTO: ItemDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemDTO' is not null or undefined
            assertParamExists('itemNewItemPost', 'itemDTO', itemDTO)
            const localVarPath = `/item/newItem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Changes item from available to not available (item sold)
         * @param {string} id Item\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemSoldItemIdPatch: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemSoldItemIdPatch', 'id', id)
            const localVarPath = `/item/soldItem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all items corresponding to a given category
         * @param {string} categoryString String of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemSortByCategoryStringGet: async (categoryString: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryString' is not null or undefined
            assertParamExists('itemSortByCategoryStringGet', 'categoryString', categoryString)
            const localVarPath = `/item/sortBy/{categoryString}`
                .replace(`{${"categoryString"}}`, encodeURIComponent(String(categoryString)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an item for sale
         * @param {ItemDTO} itemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateItemPatch: async (itemDTO: ItemDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemDTO' is not null or undefined
            assertParamExists('itemUpdateItemPatch', 'itemDTO', itemDTO)
            const localVarPath = `/item/updateItem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads images to a specific item
         * @param {string} id Item\&#39;s id
         * @param {Array<string>} files Files to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUploadImagesIdPost: async (id: string, files: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemUploadImagesIdPost', 'id', id)
            // verify required parameter 'files' is not null or undefined
            assertParamExists('itemUploadImagesIdPost', 'files', files)
            const localVarPath = `/item/uploadImages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (files) {
                localVarQueryParameter['files'] = files;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Changes logged-in user\'s password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePasswordPost: async (passwordChangeRequest: PasswordChangeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequest' is not null or undefined
            assertParamExists('userChangePasswordPost', 'passwordChangeRequest', passwordChangeRequest)
            const localVarPath = `/user/changePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Retro account
         * @param {string} username Account\&#39;s username to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteUsernameDelete: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userDeleteUsernameDelete', 'username', username)
            const localVarPath = `/user/delete/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs in Retro application
         * @param {UserLogInDTO} userLogInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignInPost: async (userLogInDTO: UserLogInDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLogInDTO' is not null or undefined
            assertParamExists('userSignInPost', 'userLogInDTO', userLogInDTO)
            const localVarPath = `/user/signIn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLogInDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out Retro application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignOutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/signOut`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Retro account
         * @param {UserCredentialsDTO} userCredentialsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignUpPost: async (userCredentialsDTO: UserCredentialsDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCredentialsDTO' is not null or undefined
            assertParamExists('userSignUpPost', 'userCredentialsDTO', userCredentialsDTO)
            const localVarPath = `/user/signUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCredentialsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all Retro\'s users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes one specific item with its id
         * @param {string} id Item\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDeleteItemIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDeleteItemIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.itemDeleteItemIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves one specific item with its id
         * @param {string} id Item\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemGetIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemGetIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.itemGetIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all items for sale on Retro
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemItemsForSaleGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemItemsForSaleGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.itemItemsForSaleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all items on Retro
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemItemsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemItemsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.itemItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Adds a new item for sale
         * @param {ItemDTO} itemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemNewItemPost(itemDTO: ItemDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemNewItemPost(itemDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.itemNewItemPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Changes item from available to not available (item sold)
         * @param {string} id Item\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemSoldItemIdPatch(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemSoldItemIdPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.itemSoldItemIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all items corresponding to a given category
         * @param {string} categoryString String of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemSortByCategoryStringGet(categoryString: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemSortByCategoryStringGet(categoryString, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.itemSortByCategoryStringGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an item for sale
         * @param {ItemDTO} itemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdateItemPatch(itemDTO: ItemDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdateItemPatch(itemDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.itemUpdateItemPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uploads images to a specific item
         * @param {string} id Item\&#39;s id
         * @param {Array<string>} files Files to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUploadImagesIdPost(id: string, files: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUploadImagesIdPost(id, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.itemUploadImagesIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Changes logged-in user\'s password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userChangePasswordPost(passwordChangeRequest: PasswordChangeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userChangePasswordPost(passwordChangeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a Retro account
         * @param {string} username Account\&#39;s username to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteUsernameDelete(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteUsernameDelete(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userDeleteUsernameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logs in Retro application
         * @param {UserLogInDTO} userLogInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSignInPost(userLogInDTO: UserLogInDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSignInPost(userLogInDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userSignInPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logs out Retro application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSignOutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSignOutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userSignOutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a new Retro account
         * @param {UserCredentialsDTO} userCredentialsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSignUpPost(userCredentialsDTO: UserCredentialsDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSignUpPost(userCredentialsDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userSignUpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all Retro\'s users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPublicDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.userUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes one specific item with its id
         * @param {string} id Item\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDeleteItemIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.itemDeleteItemIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves one specific item with its id
         * @param {string} id Item\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemGetIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemDTO> {
            return localVarFp.itemGetIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all items for sale on Retro
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemsForSaleGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemDTO>> {
            return localVarFp.itemItemsForSaleGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all items on Retro
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemItemsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemDTO>> {
            return localVarFp.itemItemsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a new item for sale
         * @param {ItemDTO} itemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemNewItemPost(itemDTO: ItemDTO, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.itemNewItemPost(itemDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Changes item from available to not available (item sold)
         * @param {string} id Item\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemSoldItemIdPatch(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.itemSoldItemIdPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all items corresponding to a given category
         * @param {string} categoryString String of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemSortByCategoryStringGet(categoryString: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemDTO>> {
            return localVarFp.itemSortByCategoryStringGet(categoryString, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an item for sale
         * @param {ItemDTO} itemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdateItemPatch(itemDTO: ItemDTO, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.itemUpdateItemPatch(itemDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploads images to a specific item
         * @param {string} id Item\&#39;s id
         * @param {Array<string>} files Files to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUploadImagesIdPost(id: string, files: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.itemUploadImagesIdPost(id, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Changes logged-in user\'s password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePasswordPost(passwordChangeRequest: PasswordChangeRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.userChangePasswordPost(passwordChangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a Retro account
         * @param {string} username Account\&#39;s username to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteUsernameDelete(username: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.userDeleteUsernameDelete(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs in Retro application
         * @param {UserLogInDTO} userLogInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignInPost(userLogInDTO: UserLogInDTO, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.userSignInPost(userLogInDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs out Retro application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignOutPost(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.userSignOutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new Retro account
         * @param {UserCredentialsDTO} userCredentialsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignUpPost(userCredentialsDTO: UserCredentialsDTO, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.userSignUpPost(userCredentialsDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all Retro\'s users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserPublicDTO>> {
            return localVarFp.userUsersGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Deletes one specific item with its id
     * @param {string} id Item\&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemDeleteItemIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).itemDeleteItemIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves one specific item with its id
     * @param {string} id Item\&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemGetIdGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).itemGetIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all items for sale on Retro
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemItemsForSaleGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).itemItemsForSaleGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all items on Retro
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemItemsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).itemItemsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a new item for sale
     * @param {ItemDTO} itemDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemNewItemPost(itemDTO: ItemDTO, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).itemNewItemPost(itemDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Changes item from available to not available (item sold)
     * @param {string} id Item\&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemSoldItemIdPatch(id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).itemSoldItemIdPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all items corresponding to a given category
     * @param {string} categoryString String of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemSortByCategoryStringGet(categoryString: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).itemSortByCategoryStringGet(categoryString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an item for sale
     * @param {ItemDTO} itemDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemUpdateItemPatch(itemDTO: ItemDTO, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).itemUpdateItemPatch(itemDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploads images to a specific item
     * @param {string} id Item\&#39;s id
     * @param {Array<string>} files Files to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public itemUploadImagesIdPost(id: string, files: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).itemUploadImagesIdPost(id, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Changes logged-in user\'s password
     * @param {PasswordChangeRequest} passwordChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userChangePasswordPost(passwordChangeRequest: PasswordChangeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userChangePasswordPost(passwordChangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a Retro account
     * @param {string} username Account\&#39;s username to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userDeleteUsernameDelete(username: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userDeleteUsernameDelete(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs in Retro application
     * @param {UserLogInDTO} userLogInDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSignInPost(userLogInDTO: UserLogInDTO, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSignInPost(userLogInDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs out Retro application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSignOutPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSignOutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new Retro account
     * @param {UserCredentialsDTO} userCredentialsDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSignUpPost(userCredentialsDTO: UserCredentialsDTO, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userSignUpPost(userCredentialsDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all Retro\'s users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userUsersGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userUsersGet(options).then((request) => request(this.axios, this.basePath));
    }
}



